//@ts-nocheck
import createCompileableStyle from 'react-native-web/dist/exports/StyleSheet/createCompileableStyle';
import i18nStyle from 'react-native-web/dist/exports/StyleSheet/i18nStyle';
import { atomic } from 'react-native-web/dist/exports/StyleSheet/compile';
import styleResolver from 'react-native-web/dist/exports/StyleSheet/styleResolver';

// 1. i18nStyle - Does swapping of ltr styles if enabled by user

// 2. createCompileableStyle - Handles shadow/text shadow conversion from RN styles to web styles

// 3. atomic - God function. Pure and memoizes input/output.
// This is a great function, it handles prefixing, converting RN specific styles to web styles and generating the CSS selector
// Input {marginTop: 10}
// Output {"r-margin-top-[hash]-10": {
//   property: "marginTop",
//   value: "10px",
//   identifier: "r-margin-top-[hash]-10",
//   rules: [{`.r-margin-top-[hash]-10: {'margin-top': '10px;`} }]
// }}

// 4. styleResolver - holds the reference of sheet object used to inject CSS. This exposes 2 functions.
// - getTextContent => for ssr style injection
// - insert => for inserting styles in style tag
// If we somehow manage to use these functions, we won't need any extra workarounds for ssr initial style injection or CSS declaration order specifictity

// Here issue is that it internally uses a cache to verify if a css rule is inserted using selector name (class name generated by RN web)
// refer line number 121 in `react-native-web/dist/exports/StyleSheet/createOrdererdCSSStyleSheetfile`.
// We can fool this hash id generator by adding a comment on top of our media query rule in this format. /* media-query + data-attr {} */ then it'll start using media-query + data-attr as cache key

const getMinWidthMediaQuery = (width, value) =>
  `@media only screen and (min-width: ${width}px) { ${value} }\n`;

export const useResponsiveStyles = (style: any) => {
  // Generate unique data-ids
  const id = 'random-id';
  const dataId = `[data-responsive="${id}"]`;

  Object.keys(style).map((value) => {
    let cssRulesForThisBreakPoint = '';

    const newStyle = createCompileableStyle(i18nStyle(style[value]));
    const results = atomic(newStyle);

    // Rule returned by atomic has css selectors, so we'll replace it with data-attr selector
    const resultsWithDataAttr = Object.keys(results).map((key) => {
      return {
        ...results[key],
        rules: results[key].rules.map((rule) => {
          return rule.replace('.' + results[key].identifier, dataId);
        }),
      };
    });

    // Loop over all the above rules and generate a single @media rule
    Object.keys(resultsWithDataAttr).forEach((key) => {
      const { rules } = resultsWithDataAttr[key];
      rules.forEach((rule) => {
        cssRulesForThisBreakPoint = cssRulesForThisBreakPoint + rule;
      });
    });

    // refer line number 121 in createOrdererdCSSStyleSheetfile to know why rule is created in such a way.
    // This is the workaround if we need to use internal sheet object by rn-web
    const rule = `
    /* ${dataId + value} {} */
    ${getMinWidthMediaQuery(value, cssRulesForThisBreakPoint)}`;

    // Here, second parameter specifies the insertion order. Setting it to 3 so responsive styles have greater specificity
    styleResolver.sheet.insert(rule, 3);
  });

  return { dataId: { responsive: id } };
};
